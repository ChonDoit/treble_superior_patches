From 4d7e4d99059622612fcd2bf7131e48d25ef4953d Mon Sep 17 00:00:00 2001
From: ChonDoit <thphantomblog@gmail.com>
Date: Sun, 3 Sep 2023 22:24:50 +0000
Subject: [PATCH 1/3] Bluetooth Timeout [1/2]

---
 core/java/android/provider/Settings.java      |  6 ++
 .../bluetooth/BluetoothEventManager.java      | 27 ++++++++
 .../bluetooth/BluetoothTimeoutReceiver.java   | 65 +++++++++++++++++++
 3 files changed, 98 insertions(+)
 create mode 100644 packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothTimeoutReceiver.java

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 48f2711e7262..b13d5f66154f 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -17978,6 +17978,12 @@ public final class Settings {
         public static final String NR_NSA_TRACKING_SCREEN_OFF_MODE =
                 "nr_nsa_tracking_screen_off_mode";
 
+	/**
+         * The amount of time in milliseconds before bluetooth is turned off
+         * @hide
+         */
+        public static final String BLUETOOTH_OFF_TIMEOUT = "bluetooth_off_timeout";
+
         /**
          * Whether to show People Space.
          * Values are:
diff --git a/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java b/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java
index 4d6dd4b538cc..9b65801540a5 100644
--- a/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java
+++ b/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java
@@ -28,7 +28,9 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.database.ContentObserver;
 import android.os.UserHandle;
+import android.provider.Settings;
 import android.telephony.TelephonyManager;
 import android.util.Log;
 
@@ -132,6 +134,19 @@ public class BluetoothEventManager {
         addHandler(BluetoothDevice.ACTION_ACL_DISCONNECTED, new AclStateChangedHandler());
 
         registerAdapterIntentReceiver();
+
+	mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.BLUETOOTH_OFF_TIMEOUT),
+                false,
+                new ContentObserver(handler) {
+            @Override
+            public void onChange(boolean selfChange) {
+                super.onChange(selfChange);
+                BluetoothTimeoutReceiver.setTimeoutAlarm(mContext,
+                        Settings.Global.getLong(context.getContentResolver(),
+                                Settings.Global.BLUETOOTH_OFF_TIMEOUT, 0));
+            }
+        });
     }
 
     /** Register to start receiving callbacks for Bluetooth events. */
@@ -294,6 +309,10 @@ public class BluetoothEventManager {
             }
             // Inform CachedDeviceManager that the adapter state has changed
             mDeviceManager.onBluetoothStateChanged(state);
+	    if (state == BluetoothAdapter.STATE_ON)
+                BluetoothTimeoutReceiver.setTimeoutAlarm(context,
+                        Settings.Global.getLong(context.getContentResolver(),
+                                Settings.Global.BLUETOOTH_OFF_TIMEOUT, 0));
         }
     }
 
@@ -309,6 +328,9 @@ public class BluetoothEventManager {
                 callback.onScanningStateChanged(mStarted);
             }
             mDeviceManager.onScanningStateChanged(mStarted);
+	    BluetoothTimeoutReceiver.setTimeoutAlarm(context,
+                    mStarted ? 0 : Settings.Global.getLong(context.getContentResolver(),
+                            Settings.Global.BLUETOOTH_OFF_TIMEOUT, 0));
         }
     }
 
@@ -345,6 +367,11 @@ public class BluetoothEventManager {
             int state = intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,
                     BluetoothAdapter.ERROR);
             dispatchConnectionStateChanged(cachedDevice, state);
+	    if (state == BluetoothAdapter.STATE_DISCONNECTED) {
+                BluetoothTimeoutReceiver.setTimeoutAlarm(context,
+                        Settings.Global.getLong(context.getContentResolver(),
+                                Settings.Global.BLUETOOTH_OFF_TIMEOUT, 0));
+            }
         }
     }
 
diff --git a/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothTimeoutReceiver.java b/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothTimeoutReceiver.java
new file mode 100644
index 000000000000..bbeb5f35134f
--- /dev/null
+++ b/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothTimeoutReceiver.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2020 The Calyx Institute
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settingslib.bluetooth;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+import java.util.Date;
+
+public class BluetoothTimeoutReceiver extends BroadcastReceiver {
+    private static final String TAG = "BluetoothTimeoutReceiver";
+
+    private static final String INTENT_TIMEOUT = "android.bluetooth.intent.TIMEOUT";
+
+    public static void setTimeoutAlarm(Context context, long alarmTime) {
+        Intent intent = new Intent(INTENT_TIMEOUT);
+        intent.setClassName("com.android.settings", "com.android.settingslib.bluetooth.BluetoothTimeoutReceiver");
+        PendingIntent pending = PendingIntent.getBroadcast(
+                context, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_MUTABLE);
+        AlarmManager alarmManager =
+                (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+
+        if (alarmTime != 0) {
+            alarmTime = System.currentTimeMillis() + alarmTime;
+            Log.d(TAG, "setTimeoutAlarm(): alarmTime = " + new Date(alarmTime));
+            alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pending);
+        } else
+            alarmManager.cancel(pending);
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (intent.getAction() == null && !intent.getAction().equals(INTENT_TIMEOUT)) {
+            return;
+        }
+        if (bluetoothAdapter != null) {
+            if (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON &&
+                    bluetoothAdapter.getConnectionState() == BluetoothAdapter.STATE_DISCONNECTED)
+                bluetoothAdapter.disable();
+        } else {
+            Log.e(TAG, "bluetoothAdapter is NULL!!");
+        }
+    }
+}
-- 
2.34.1

